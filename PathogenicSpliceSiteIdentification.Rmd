---
title: "Pathogenic Splice Site Identification"
output: html_notebook
---
Import libraries
```{r}
suppressPackageStartupMessages(library(Homo.sapiens))
```


Functions
```{r}
#Function to convert bed--> genomic ranges --> add gene IDs --> select gene ID of interest
GetJunctionGeneID<- function(bed, genes, GeneIDs) {
  #Set column names
  colnames(bed)<- c("Chrom", "Start", "End", "Name", "Score", "Strand", "ThickStart", "ThickEnd","ItemRGB", "BlockCount", "BlockSizes", "BlockStarts")
  #Convert bed file to genomic ranges, add score as metadata column
  GR<- makeGRangesFromDataFrame(bed)
  values(GR)<- DataFrame(Score=bed$Score, Name=bed$Name)
  
  #Get overlaps of GRanges bed info and all known genes
  ranges<- subsetByOverlaps(GR,genes)
  
  #Get the geneID names, associate back with the overlap GRanges object
  hits<- findOverlaps(GR,genes)
  geneid <- CharacterList(split(genes$gene_id[subjectHits(hits)],queryHits(hits)))
  mcols(ranges) <- DataFrame(mcols(ranges), geneid)
  
  Junctions_GeneIDs<- as.data.frame(ranges)
  GeneJunctions_GeneIDs<- Junctions_GeneIDs[Junctions_GeneIDs$geneid %in% GeneIDs,]
  return(GeneJunctions_GeneIDs)
}

#Write function that filters junctions based on pre-built control list of junctions + depth
FilterJunctions<- function(ControlJunctions, SampleJunctions, DepthFilter){
  #Get rid of any in control list
  ControlJunctionsInSample<- SampleJunctions$Name %in% ControlJunctions$Name
  UniqueTTNJunctions<- SampleJunctions[!ControlJunctionsInSample,]
  
  #Get rid of any with fewer reads supporting it than the depth filter
  UniqueSample_Depth<- UniqueTTNJunctions[UniqueTTNJunctions$Score>DepthFilter,]
  print(nrow(UniqueSample_Depth))
  return(UniqueSample_Depth)
}

#Alternative to above junction- rather than setting a depth filter, filter junctions based on the mean depth of junctions of that gene of that sample. Also removes any in control list.
FilterJunctions_BasedOnMeanDepth<- function(ControlJunctions, SampleJunctions, Percentage){
  SampleJunctions$geneid<- as.character(SampleJunctions$geneid)
  #Get rid of any with fewer reads supporting it than 10% of the mean number of reads supporting junctions 
  #of THAT GENE in THAT SAMPLE
 SampleJunctions_Depth<-as.data.frame(group_by(SampleJunctions, geneid) %>% mutate(mean=mean(Score))) %>% filter(Score>(mean*Percentage))
  
  #Get rid of any in control list
  ControlJunctionsInSample<- SampleJunctions_Depth$Name %in% ControlJunctions$Name
  UniqueTTNJunctions<- SampleJunctions_Depth[!ControlJunctionsInSample,]
}
```


#Filtering junctions in all samples

Filter optimization described in PathogenicSpliceSiteIdentification_FilterOptimization.Rmd

Import bed files: samples 1, 3-8, 11-13, 15-19 (samples 2 and 9 already read in, samples 10 and 14 have no bed file)
Select just junctions of interest

Read in bed files
```{r}
#For novel tx alignment
wd<- "//Cifs2/rcdata$/UKRNASeq/RawFiles/Bed/"
#For Original alignment
#wd<- "//Cifs2/rcdata$/UKRNASeq/PathogenicSpliceSiteAnalysis/Junctions.bed/"

#get list of samples needed
Samples<-c(1:9,11:13,15:19)
FileList<- paste(wd, Samples, ".junctions.bed", sep="")
ControlFileList<- paste(wd,"UK-Control-", c(1:5), ".junctions.bed", sep="")

#Read in bed files
AllBed<- lapply(FileList, read.table, sep="\t", header=FALSE, stringsAsFactors=FALSE)
AllControlBed<- AllBed<- lapply(ControlFileList, read.table, sep="\t", header=FALSE, stringsAsFactors=FALSE)
```


#Filter bed files based on:
  1) genes of interest
  2) Junctions not in controls list (controls list filtered for present in < 2 samples + <10 reads)
  3) Depth


Get junctions in genes of interest + create controls list
```{r}
#Set genes of interest
GOI<- c("7273","4000", "4624","4625", "88") 
#TTN, LMNA, MYH6, MYH7, ACTN2, 

#Get Genes of interest junctions, in CM samples
AllGOIJunctions<- lapply(AllBed, GetJunctionGeneID, genes=genes, GeneIDs=GOI)

#Create controls list: Get junctions in genes of interest in controls, then filter to get final list of junctions in controls to remove from CM group
  #Get junctions
  AllGOIControlJunctions<- lapply(AllControlBed, GetJunctionGeneID, genes=genes, GeneIDs=GOI)
  
  #Filter control junctions
    #Take list of all junctions found in controls --> to data.frame with 5 columns (1 for each control sample) for each
    #junction. Include the number of reads that support that junction for each sample, entering a 0 if it doesn't appear
    AllGOIControlJunctions<-lapply(AllGOIControlJunctions, function(x){x[,6:7]})
    for (i in 1:length(AllGOIControlJunctions)){
      colnames(AllGOIControlJunctions[[i]])<- c(paste("Score_", i,sep=""), "Name")
    }
    
    AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions[[1]], 
                                          AllGOIControlJunctions[[2]], by="Name", all=TRUE)
    AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions_Merged, 
                                          AllGOIControlJunctions[[3]], by="Name", all=TRUE)
    AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions_Merged, 
                                          AllGOIControlJunctions[[4]], by="Name", all=TRUE)
    AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions_Merged, 
                                          AllGOIControlJunctions[[5]], by="Name", all=TRUE)
    #1067 total junctions
    
    #Convert NA to 0
    AllGOIControlJunctions_Merged[is.na(AllGOIControlJunctions_Merged)]<- 0
    
    #Add column with maximum score for each junction
    AllGOIControlJunctions_Merged$Max<- rowMax(as.matrix(AllGOIControlJunctions_Merged[,2:6]))
    
    #Add column with Number of samples that have that junction
    AllGOIControlJunctions_Merged$SamplesWithJunction<- rowSums(AllGOIControlJunctions_Merged[,2:6]>0)
    
    #Get list of junctions to NOT look at in sample 9: Appears in >1 control samples + supported by > 10 reads
    ControlJunctions_Filtered<- AllGOIControlJunctions_Merged[AllGOIControlJunctions_Merged$Max>10,]
    ControlJunctions_Filtered<- ControlJunctions_Filtered[ControlJunctions_Filtered$SamplesWithJunction>1,]

```



#Get filtered list of junctions for each sample
```{r}
AllFilteredJunctions<- lapply(AllGOIJunctions, FilterJunctions, ControlJunctions=ControlJunctions_Filtered, DepthFilter=20)
```

#Get filtered list using alternative filtering: based on mean read depth
```{r}
AllFilteredJunctions<- lapply(AllGOIJunctions, FilterJunctions_BasedOnMeanDepth, ControlJunctions=ControlJunctions_Filtered,.01)

unlist(lapply(AllFilteredJunctions, nrow))
```

Merge data together for export
```{r}
#In each df, select just score, name, and gene id
JunctionsSubset<- lapply(AllFilteredJunctions,function(x){x[,5:8]})

#Get rid of any samples with junctions of interest
SamplesSubset<-Samples[lapply(JunctionsSubset, nrow)>0]
JunctionsSubset<- JunctionsSubset[lapply(JunctionsSubset, nrow)>0]

#Add new column with gene ID
for (i in 1:length(JunctionsSubset)){
  JunctionsSubset[[i]]$Sample<- SamplesSubset[i]
}

multi_full<- do.call(rbind,JunctionsSubset)
```


```{r}
write.csv(multi_full, paste(wd, "AllSamples_PotentialPathogenicJunctions_FilteredControlsRemoved_DepthBasedOnMean.01_TTN.LMNA.MYH6.MYH7.ACTN2.csv", sep=""))
```

