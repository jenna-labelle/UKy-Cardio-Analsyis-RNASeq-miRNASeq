---
title: "Pathogenic Splice Site Identification"
output: html_notebook
---
Import libraries
```{r}
suppressPackageStartupMessages(library(Homo.sapiens))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(org.Hs.eg.db))
```


Functions
```{r}
#Convert bed--> genomic ranges --> add gene IDs --> select gene ID of interest
GetJunctionGeneID<- function(bed, genes, GeneIDs) {
  #Set column names
  colnames(bed)<- c("Chrom", "Start", "End", "Name", "Score", "Strand", "ThickStart", "ThickEnd","ItemRGB", "BlockCount", "BlockSizes", "BlockStarts")
  #Convert bed file to genomic ranges, add score as metadata column
  GR<- makeGRangesFromDataFrame(bed)
  values(GR)<- DataFrame(Score=bed$Score, Name=bed$Name)
  
  #Get overlaps of GRanges bed info and all known genes
  ranges<- subsetByOverlaps(GR,genes)
  
  #Get the geneID names, associate back with the overlap GRanges object
  hits<- findOverlaps(GR,genes)
  geneid <- CharacterList(split(genes$gene_id[subjectHits(hits)],queryHits(hits)))
  mcols(ranges) <- DataFrame(mcols(ranges), geneid)
  
  Junctions_GeneIDs<- as.data.frame(ranges)
  GeneJunctions_GeneIDs<- Junctions_GeneIDs[Junctions_GeneIDs$geneid %in% GeneIDs,]
  return(GeneJunctions_GeneIDs)
}

#Filter junctions based on pre-built control list of junctions + depth
FilterJunctions<- function(ControlJunctions, SampleJunctions, DepthFilter){
  #Get rid of any in control list
  ControlJunctionsInSample<- SampleJunctions$Name %in% ControlJunctions$Name
  UniqueTTNJunctions<- SampleJunctions[!ControlJunctionsInSample,]
  
  #Get rid of any with fewer reads supporting it than the depth filter
  UniqueSample_Depth<- UniqueTTNJunctions[UniqueTTNJunctions$Score>DepthFilter,]
  return(UniqueSample_Depth)
}

#Alternative to above function- rather than setting a depth filter, filter junctions based on the mean depth of junctions of that gene of that sample. Also removes any in control list.
FilterJunctions_BasedOnMeanDepth<- function(ControlJunctions, SampleJunctions, Percentage){
  SampleJunctions$geneid<- as.character(SampleJunctions$geneid)
  #Get rid of any with fewer reads supporting it than 10% of the mean number of reads supporting junctions 
  #of THAT GENE in THAT SAMPLE
 SampleJunctions_Depth<-as.data.frame(group_by(SampleJunctions, geneid) %>% mutate(mean=mean(Score))) %>% filter(Score>(mean*Percentage))
  
  #Get rid of any in control list
  ControlJunctionsInSample<- SampleJunctions_Depth$Name %in% ControlJunctions$Name
  UniqueTTNJunctions<- SampleJunctions_Depth[!ControlJunctionsInSample,]
}

#Function that splits "name" into two columns: splice site A and B, and concatanates with chromosome to give unique splice site
SpliceSiteSplit<- function(Junctions){
  AllJunctions<- unlist(lapply(strsplit(Junctions$Name, ":"), function(x){x[2]}))
  SpliceSites<- strsplit(AllJunctions, "-")
  SpliceSiteA<- unlist(lapply(SpliceSites, function(x){x[1]}))
  SpliceSiteB<- unlist(lapply(SpliceSites, function(x){x[2]}))
  Junctions$SpliceSiteA<- paste(Junctions$seqnames, SpliceSiteA,sep=":")
  Junctions$SpliceSiteB<- paste(Junctions$seqnames, SpliceSiteB,sep=":")
  return(Junctions)
}

#For determining canonoical sites: Get rid of any with fewer reads supporting it than some percentage of the mean number of reads supporting junctions of THAT GENE in THAT SAMPLE
FilterControlJunctions_BasedOnMeanDepth<- function(Junctions, Percentage){
  Junctions$geneid<- as.character(Junctions$geneid)
 SampleJunctions_Depth<-as.data.frame(group_by(Junctions, geneid) %>% mutate(mean=mean(Score))) %>% filter(Score>(mean*Percentage))
}

#For determining canonical splice sites: group by splice site A or B and sum all of A or all of B- i.e., if an A splice site has 2 B splice sites, sum the scores for both sites for the A and keep separate for the B
GetCanonicalSpliceSiteSum<-function(DepthFilteredJunctions, AorB){
  SpliceSite<-paste("SpliceSite", AorB, sep="")
  SummedSpliceA<- DepthFilteredJunctions %>% group_by_at(vars(SpliceSite))%>% summarize(MeanScore=sum(Score)) %>% as.data.frame
}

#For adding column to partially filtered CM junctions annotating whether each side of the junction is "canonical" and what the mean depth of that "canonical" junction is in controls
FilterOutBothNeitherCanonical<- function(SplitJunction, MergedAControlSpliceSites, MergedBControlSpliceSites){
  #Splice site A not in list:
  SplitJunction$A_Canonical<- SplitJunction$SpliceSiteA %in% MergedAControlSpliceSites$SpliceSiteA
 
  #Splice site B not in list:
  SplitJunction$B_Canonical<-SplitJunction$SpliceSiteB %in% MergedBControlSpliceSites$SpliceSiteB

  #Neither splice site canonical
  SplitJunction$Sum<- rowSums(SplitJunction[,11:12])
  SplitJunction$NeitherCanonical<- SplitJunction$Sum==0
  
  #Both splice sites canonical
  SplitJunction$BothCanonical<- SplitJunction$Sum==2
  
  #One splice site canonical one not
  SplitJunction$OneCanonical<- SplitJunction$Sum==1
  
  #Depth of junction for controls
  ControlDepths<- merge(SplitJunction, MergedAControlSpliceSites, by="SpliceSiteA",all.x=TRUE)
  ControlDepths<-merge(ControlDepths, MergedBControlSpliceSites,by="SpliceSiteB",all.x=TRUE)
  ControlDepths$MeanControlA<- rowMeans(ControlDepths[,17:21])
  ControlDepths$MeanControlB<- rowMeans(ControlDepths[,22:26])
  ControlDepths[is.na(ControlDepths)]<- 0
  return(ControlDepths[,c(3:7,9,10,2,1,8,11,12,14:16,27,28)])
  
}

```


#Filtering junctions in all samples

Filter optimization described in PathogenicSpliceSiteIdentification_FilterOptimization.Rmd

Import bed files: samples 1, 3-8, 11-13, 15-19 (samples 2 and 9 already read in, samples 10 and 14 have no bed file)
Select just junctions of interest

Read in bed files
```{r}
#For novel tx alignment
wd<- "//Cifs2/rcdata$/UKRNASeq/RawFiles/Bed/"
#For Original alignment
#wd<- "//Cifs2/rcdata$/UKRNASeq/PathogenicSpliceSiteAnalysis/Junctions.bed/"

#get list of samples needed
Samples<-c(1:9,11:13,15:19)
FileList<- paste(wd, Samples, ".junctions.bed", sep="")
ControlFileList<- paste(wd,"UK-Control-", c(1:5), ".junctions.bed", sep="")

#Read in bed files
AllBed<- lapply(FileList, read.table, sep="\t", header=FALSE, stringsAsFactors=FALSE)
AllControlBed<- AllBed<- lapply(ControlFileList, read.table, sep="\t", header=FALSE, stringsAsFactors=FALSE)
```


#Filter bed files based on:
  1) genes of interest
  2) Junctions not in controls list (controls list filtered for present in < 2 samples + <10 reads)
  3) Depth


Get junctions in genes of interest + create controls list
```{r}
#Read in txdb- only needs to be done once
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
  
#Get full list of genes and genes of interest
genes <- genes(TxDb.Hsapiens.UCSC.hg19.knownGene)

#Input genes of interest- as gene name
geneNames<- read.csv("//Cifs2/rcdata$/UKRNASeq/PathogenicSpliceSiteAnalysis/GenesofInterest.csv",header=FALSE)

#Convert to entrez gene ids
GOI<- unname(mapIds(org.Hs.eg.db, keys=as.character(geneNames$V1), column="ENTREZID",keytype="SYMBOL"))


#Get Genes of interest junctions, in CM samples
AllGOIJunctions<- lapply(AllBed, GetJunctionGeneID, genes=genes, GeneIDs=GOI)

#Create controls list: Get junctions in genes of interest in controls, then filter to get final list of junctions in controls to remove from CM group
  #Get junctions
  AllGOIControlJunctions<- lapply(AllControlBed, GetJunctionGeneID, genes=genes, GeneIDs=GOI)
  
  #Filter control junctions
    #Take list of all junctions found in controls --> to data.frame with 5 columns (1 for each control sample) for each
    #junction. Include the number of reads that support that junction for each sample, entering a 0 if it doesn't appear
    AllGOIControlJunctions_subset<-lapply(AllGOIControlJunctions, function(x){x[,6:7]})
    for (i in 1:length(AllGOIControlJunctions_subset)){
      colnames(AllGOIControlJunctions_subset[[i]])<- c(paste("Score_", i,sep=""), "Name")
    }
    
    AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions_subset[[1]], 
                                          AllGOIControlJunctions_subset[[2]], by="Name", all=TRUE)
    AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions_Merged, 
                                          AllGOIControlJunctions_subset[[3]], by="Name", all=TRUE)
    AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions_Merged, 
                                          AllGOIControlJunctions_subset[[4]], by="Name", all=TRUE)
    AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions_Merged, 
                                          AllGOIControlJunctions_subset[[5]], by="Name", all=TRUE)
    
    #Convert NA to 0
    AllGOIControlJunctions_Merged[is.na(AllGOIControlJunctions_Merged)]<- 0
    
    #Add column with maximum score for each junction
    AllGOIControlJunctions_Merged$Max<- rowMax(as.matrix(AllGOIControlJunctions_Merged[,2:6]))
    
    #Add column with Number of samples that have that junction
    AllGOIControlJunctions_Merged$SamplesWithJunction<- rowSums(AllGOIControlJunctions_Merged[,2:6]>0)
    
    #Get list of junctions to NOT look at: Appears in >1 control samples + supported by > 5 reads
    ControlJunctions_Filtered<- AllGOIControlJunctions_Merged[AllGOIControlJunctions_Merged$Max>5,]
    ControlJunctions_Filtered<- ControlJunctions_Filtered[ControlJunctions_Filtered$SamplesWithJunction>1,]

```



#Get filtered list of junctions for each sample
```{r}
AllFilteredJunctions<- lapply(AllGOIJunctions, FilterJunctions, ControlJunctions=ControlJunctions_Filtered, DepthFilter=5)
sum(unlist(lapply(AllFilteredJunctions, nrow)))
sum(unlist(lapply(AllFilteredJunctions, nrow)))
```

#Get filtered list using alternative filtering: based on mean read depth
#Currently not in use
```{r}
AllFilteredJunctions<- lapply(AllGOIJunctions, FilterJunctions_BasedOnMeanDepth, ControlJunctions=ControlJunctions_Filtered,.01)

unlist(lapply(AllFilteredJunctions, nrow))
```

Merge data together for export
```{r}
#In each df, select just score, name, and gene id
JunctionsSubset<- lapply(AllFilteredJunctions,function(x){x[,5:8]})

#Get rid of any samples with junctions of interest
SamplesSubset<-Samples[lapply(JunctionsSubset, nrow)>0]
JunctionsSubset<- JunctionsSubset[lapply(JunctionsSubset, nrow)>0]

#Add new column with gene ID
for (i in 1:length(JunctionsSubset)){
  JunctionsSubset[[i]]$Sample<- SamplesSubset[i]
}

multi_full<- do.call(rbind,JunctionsSubset)
```


```{r}
write.csv(multi_full, paste(wd, "AllSamples_PotentialPathogenicJunctions_FilteredControlsRemoved_DepthBasedOnMean.01_TTN.LMNA.MYH6.MYH7.ACTN2.csv", sep=""))
```


#New filtering: based on "canonical" control splice sites
Canonical defined as occuring in ALL control samples with at least 1% (this may change, variable in function that can be changed) of mean depth for that gene for that sample

These canonical splice sites for all controls are merged into 1 df for "A" splice sites and 1 df for "B" splice sites

Creating canonical splice site lists:
```{r}
#Get junctions in genes of interest
AllGOIControlJunctions<- lapply(AllControlBed, GetJunctionGeneID, genes=genes, GeneIDs=GOI)
```

```{r}
#Split splice sites into separate, unique column
AllSplitControlJunctions<- lapply(AllGOIControlJunctions, SpliceSiteSplit)

#Filter all control junctions by depth
AllDepthFilteredControlJunctions<- lapply(AllSplitControlJunctions, FilterControlJunctions_BasedOnMeanDepth, Percentage=.80)

#Get all A and B spice sites (summed) for each sample
AllAControlSpliceSites<-lapply(AllDepthFilteredControlJunctions, GetCanonicalSpliceSiteSum, "A")
AllBControlSpliceSites<-lapply(AllDepthFilteredControlJunctions, GetCanonicalSpliceSiteSum, "B")

#Rename columns to include sample info
for (i in 1:length(AllAControlSpliceSites)){
  colnames(AllAControlSpliceSites[[i]])<- c("SpliceSiteA", paste(i, "MeanScore", sep=":"))
}

for (i in 1:length(AllBControlSpliceSites)){
  colnames(AllBControlSpliceSites[[i]])<- c("SpliceSiteB", paste(i, "MeanScore", sep=":"))
}

#Merge all A splice sites into one df, all B into one df
MergedAControlSpliceSites<- AllAControlSpliceSites %>% Reduce(function(dtf1, dtf2) left_join(dtf1, dtf2, by="SpliceSiteA"), .) %>% na.omit
  
MergedBControlSpliceSites<- AllBControlSpliceSites %>% Reduce(function(dtf1, dtf2) left_join(dtf1, dtf2, by="SpliceSiteB"), .) %>% na.omit
```

```{r}
nrow (MergedAControlSpliceSites) + nrow (MergedAControlSpliceSites)

```

#Filter CM samples based on canonical junctions + Depth

Remove from "interesting" list if:
1) Junction found in > 1 control
2) Junction supported by >10 reads in any 1 control
3) Junction is supported by at least 2 reads in that sample (may change this number)
4) Both sides of junction are canonical (found in Side A and Side B list)
5) Both sides of junction are non-canonical
6) Filter based on "norm" score: depth of junction in CM sample / mean depth of CANONICAL side of that junction in control samples

Filters 1-3 have already been used:
```{r}
AllFilteredJunctions<- lapply(AllGOIJunctions, FilterJunctions, ControlJunctions=ControlJunctions_Filtered, DepthFilter=5)
sum(unlist(lapply(AllFilteredJunctions, nrow)))
```


Filters 4 and 5:
```{r}
AllSplitJunctions<- lapply(AllFilteredJunctions[2:17], SpliceSiteSplit)

#Add annotation detailing whether each side of the junction is "canonical" and what the mean depth for that canonical junction is (in controls)
AllCanonicalAnnotatedJunctions<- lapply(AllSplitJunctions, FilterOutBothNeitherCanonical, MergedAControlSpliceSites,MergedBControlSpliceSites)

#Select just junctions where exactly one side is canonical
AllOneCanonicalJunctions<- lapply(AllCanonicalAnnotatedJunctions, function(x) {x[x$OneCanonical=="TRUE",]})

sum(unlist(lapply(AllOneCanonicalJunctions, nrow)))

```

Filter 6
```{r}
NormScore<- lapply(AllOneCanonicalJunctions, function(x){
  x$MeanBothSites<- rowSums(x[,16:17])
  x$NormScore<- x$Score/x$MeanBothSites
  return(x)
})
```

Add in column for sample number, merge together
```{r}
Samples<-Samples[2:17]
for (i in 1:length(NormScore)){
  NormScore[[i]]$SampleID<- Samples[i]
}



multi_full<- do.call(rbind,NormScore)

nrow(multi_full[multi_full$NormScore>0.1,])
```

```{r}
write.csv(test, paste(wd, "AllFilteredCMJunctions_ControlRemoved5_Depth10_1CanSite_Can.8_Full62GeneList.csv"))
```



#For optimizing settings of filters: function to run entire analysis, output whether or not positive control junctions are detected

```{r}
#Set positive controls we want to discover in CM junctions
PositiveControlJunctions<- c("chr2:179584992-179585265",
                             "chr2:179603079-179603867",
                             "chr2:179603167-179603867",
                             "chr2:179603229-179603867")

test[test$Name %in% PositiveControlJunctions,]



#Get Genes of interest junctions, in CM samples
AllGOIJunctions<- lapply(AllBed, GetJunctionGeneID, genes=genes, GeneIDs=GOI)
  
#Get junctions in genes of interest in controls
AllGOIControlJunctions<- lapply(AllControlBed, GetJunctionGeneID, genes=genes, GeneIDs=GOI)
c(2:6,8:15,17)

test<-EntireFiltering(c(2:17),AllGOIJunctions, AllGOIControlJunctions, 
                      ControlsListNReads=5, 
                      RawDepthFilter=10, 
                      ControlSiteFilteringPercentage=.8,
                      PositiveControlJunctions)

EntireFiltering<- function(SamplesToUse, AllGOIJunctions, AllGOIControlJunctions, ControlsListNReads,RawDepthFilter,ControlSiteFilteringPercentage, PositiveControlJunctions){
    #Print out input settings
    print("INPUT SETTINGS")
    print(paste("Number of reads threshold for considering JUNCTION as control (Filter 2):",ControlsListNReads))
    print(paste("Raw Depth Filter (Filter 3):", RawDepthFilter))
    print(paste("Percent of Mean reads in gene for that sample for considering SPLICE SITE as canonical (Filter 4):", ControlSiteFilteringPercentage))
    print("")
    print("")
    #Filter control junctions
      #Take list of all junctions found in controls --> to data.frame with 5 columns (1 for each control sample) for       each
      #junction. Include the number of reads that support that junction for each sample, entering a 0 if it doesn't       appear
      AllGOIControlJunctions_subset<-lapply(AllGOIControlJunctions, function(x){x[,6:7]})
      for (i in 1:length(AllGOIControlJunctions_subset)){
        colnames(AllGOIControlJunctions_subset[[i]])<- c(paste("Score_", i,sep=""), "Name")
      }
      
      AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions_subset[[1]], 
                                            AllGOIControlJunctions_subset[[2]], by="Name", all=TRUE)
      AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions_Merged, 
                                            AllGOIControlJunctions_subset[[3]], by="Name", all=TRUE)
      AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions_Merged, 
                                            AllGOIControlJunctions_subset[[4]], by="Name", all=TRUE)
      AllGOIControlJunctions_Merged<- merge(AllGOIControlJunctions_Merged, 
                                            AllGOIControlJunctions_subset[[5]], by="Name", all=TRUE)
      #Convert NA to 0
      AllGOIControlJunctions_Merged[is.na(AllGOIControlJunctions_Merged)]<- 0
      #Add column with maximum score for each junction
      AllGOIControlJunctions_Merged$Max<- rowMax(as.matrix(AllGOIControlJunctions_Merged[,2:6]))
      #Add column with Number of samples that have that junction
      AllGOIControlJunctions_Merged$SamplesWithJunction<- rowSums(AllGOIControlJunctions_Merged[,2:6]>0)
      #Get list of junctions to NOT look at: Appears in >1 control samples + supported by > 10 reads
      ControlJunctions_Filtered<- AllGOIControlJunctions_Merged[AllGOIControlJunctions_Merged$Max>ControlsListNReads,]
      ControlJunctions_Filtered<- ControlJunctions_Filtered[ControlJunctions_Filtered$SamplesWithJunction>1,]
      
  ############################################################################################################    
  #Get filtered list of junctions for each sample
  AllGOIJunctions<- AllGOIJunctions[SamplesToUse]
  AllFilteredJunctions<- lapply(AllGOIJunctions, FilterJunctions, 
                                ControlJunctions=ControlJunctions_Filtered, DepthFilter=RawDepthFilter)
  print(paste("Number of junctions after control junction filtering + Raw depth filtering (Filter 2/3):", 
              sum(unlist(lapply(AllFilteredJunctions, nrow)))))
  ############################################################################################################
  #Create control splice site filtered list
    #Split splice sites into separate, unique column
    AllSplitControlJunctions<- lapply(AllGOIControlJunctions, SpliceSiteSplit)
    
    #Filter all control junctions by depth
    AllDepthFilteredControlJunctions<- lapply(AllSplitControlJunctions, 
                                              FilterControlJunctions_BasedOnMeanDepth,
                                              Percentage=ControlSiteFilteringPercentage)
    
    #Get all A and B spice sites (summed) for each sample
    AllAControlSpliceSites<-lapply(AllDepthFilteredControlJunctions, GetCanonicalSpliceSiteSum, "A")
    AllBControlSpliceSites<-lapply(AllDepthFilteredControlJunctions, GetCanonicalSpliceSiteSum, "B")
    
    #Rename columns to include sample info
    for (i in 1:length(AllAControlSpliceSites)){
      colnames(AllAControlSpliceSites[[i]])<- c("SpliceSiteA", paste(i, "MeanScore", sep=":"))
    }
    
    for (i in 1:length(AllBControlSpliceSites)){
      colnames(AllBControlSpliceSites[[i]])<- c("SpliceSiteB", paste(i, "MeanScore", sep=":"))
    }
    
    #Merge all A splice sites into one df, all B into one df
    MergedAControlSpliceSites<- AllAControlSpliceSites %>% Reduce(function(dtf1, dtf2) left_join(dtf1, dtf2, by="SpliceSiteA"), .) %>% na.omit
      
    MergedBControlSpliceSites<- AllBControlSpliceSites %>% Reduce(function(dtf1, dtf2) left_join(dtf1, dtf2, by="SpliceSiteB"), .) %>% na.omit
  print(paste("Number of control canonical splice sites (control splice sites after filter 4):", 
        (nrow (MergedAControlSpliceSites) + nrow (MergedBControlSpliceSites))))
  
  
  ############################################################################################################
  #Filter CM junctions based on canonical splice sites
  AllSplitJunctions<- lapply(AllFilteredJunctions, SpliceSiteSplit)

  #Add annotation detailing whether each side of the junction is "canonical" and what the mean depth for that
  #canonical junction is (in controls)
  AllCanonicalAnnotatedJunctions<- lapply(AllSplitJunctions, FilterOutBothNeitherCanonical,
                                          MergedAControlSpliceSites,MergedBControlSpliceSites)
  
  #Select just junctions where exactly one side is canonical
  AllOneCanonicalJunctions<- lapply(AllCanonicalAnnotatedJunctions, function(x) {x[x$OneCanonical=="TRUE",]})
  
  print(paste("Number of CM junctions after filtering based on canonical splice sites (CM junctions after filter 4):",
        sum(unlist(lapply(AllOneCanonicalJunctions, nrow)))))
  
  ############################################################################################################
  #Add column for norm score
  NormScore<- lapply(AllOneCanonicalJunctions, function(x){
  x$MeanBothSites<- rowSums(x[,16:17])
  x$NormScore<- x$Score/x$MeanBothSites
  return(x)
    })
  #Add column for naming based on sample
  Samples<-Samples[SamplesToUse]
  for (i in 1:length(NormScore)){
  NormScore[[i]]$SampleID<- Samples[i]
}

  #merge
  multi_full<- do.call(rbind,NormScore)

  print(paste("Number of CM junctions with Norm score > 0.1 (Filter 5):", nrow(multi_full[multi_full$NormScore>0.1,])))
  print(paste("Number of CM junctions with Norm score > 0.01 (Filter 5):", nrow(multi_full[multi_full$NormScore>0.01,])))
  
  #Test for presence of positive control CM junctions
  print(paste("Number of CM positive control junctions:", nrow((multi_full[multi_full$Name %in% PositiveControlJunctions,]))))
  return(multi_full)
}
```








